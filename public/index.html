<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>To-Do List</title>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #f5f5f5;
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
    }

    h1 {
      text-align: center;
      margin-bottom: 20px;
      color: #333;
    }

    /* Connection Status */
    .connection-status {
      text-align: center;
      padding: 10px;
      margin-bottom: 15px;
      border-radius: 4px;
      font-size: 14px;
    }

    .connection-status.connected {
      background: #d4edda;
      color: #155724;
    }

    .connection-status.disconnected {
      background: #f8d7da;
      color: #721c24;
    }

    .connection-status.loading {
      background: #fff3cd;
      color: #856404;
    }

    /* Config Panel */
    .config-panel {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }

    .config-panel h3 {
      margin-bottom: 15px;
      color: #333;
    }

    .config-panel .form-group {
      margin-bottom: 10px;
    }

    .config-panel input {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }

    .config-panel .btn-row {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }

    /* Form Styles */
    .task-form {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }

    .form-row {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }

    .form-group {
      flex: 1;
      min-width: 150px;
    }

    .form-group label {
      display: block;
      margin-bottom: 4px;
      font-size: 14px;
      color: #666;
    }

    .form-group input,
    .form-group select {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }

    .form-group input:focus,
    .form-group select:focus {
      outline: none;
      border-color: #007bff;
    }

    .task-input {
      flex: 2;
    }

    .recurring-options {
      display: none;
      background: #f9f9f9;
      padding: 10px;
      border-radius: 4px;
      margin-top: 10px;
    }

    .recurring-options.visible {
      display: block;
    }

    .weekday-selector {
      display: none;
      gap: 5px;
      flex-wrap: wrap;
      margin-top: 10px;
    }

    .weekday-selector.visible {
      display: flex;
    }

    .weekday-btn {
      padding: 5px 10px;
      border: 1px solid #ddd;
      background: white;
      border-radius: 4px;
      cursor: pointer;
    }

    .weekday-btn.selected {
      background: #007bff;
      color: white;
      border-color: #007bff;
    }

    .interval-input {
      display: none;
      align-items: center;
      gap: 10px;
      margin-top: 10px;
    }

    .interval-input.visible {
      display: flex;
    }

    .interval-input input {
      width: 80px;
    }

    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }

    .btn-primary {
      background: #007bff;
      color: white;
    }

    .btn-primary:hover {
      background: #0056b3;
    }

    .btn-secondary {
      background: #6c757d;
      color: white;
    }

    .btn-cancel {
      background: #dc3545;
      color: white;
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    /* Filter Bar */
    .filter-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      flex-wrap: wrap;
      gap: 10px;
    }

    .toggle-completed {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
    }

    .toggle-completed input {
      cursor: pointer;
    }

    /* Task List */
    .task-list {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      overflow: hidden;
    }

    .task-item {
      display: flex;
      align-items: center;
      padding: 15px;
      border-bottom: 1px solid #eee;
      gap: 15px;
    }

    .task-item:last-child {
      border-bottom: none;
    }

    .task-item.completed {
      opacity: 0.6;
      background: #f9f9f9;
    }

    .task-item.completed .task-text {
      text-decoration: line-through;
    }

    .task-checkbox {
      width: 20px;
      height: 20px;
      cursor: pointer;
    }

    .task-content {
      flex: 1;
    }

    .task-text {
      font-size: 16px;
      margin-bottom: 5px;
    }

    .task-meta {
      display: flex;
      gap: 10px;
      font-size: 12px;
      color: #666;
      flex-wrap: wrap;
    }

    .task-meta span {
      display: flex;
      align-items: center;
      gap: 3px;
    }

    .priority-badge {
      padding: 2px 8px;
      border-radius: 10px;
      font-size: 11px;
      font-weight: bold;
      text-transform: uppercase;
    }

    .priority-high {
      background: #f8d7da;
      color: #721c24;
    }

    .priority-medium {
      background: #fff3cd;
      color: #856404;
    }

    .priority-low {
      background: #d4edda;
      color: #155724;
    }

    .category-badge {
      background: #e2e3e5;
      color: #383d41;
      padding: 2px 8px;
      border-radius: 10px;
      font-size: 11px;
    }

    .recurring-badge {
      background: #cce5ff;
      color: #004085;
      padding: 2px 8px;
      border-radius: 10px;
      font-size: 11px;
    }

    .reminder-badge {
      background: #e2d5f1;
      color: #5a3d7a;
      padding: 2px 8px;
      border-radius: 10px;
      font-size: 11px;
    }

    .task-actions {
      display: flex;
      gap: 5px;
    }

    .task-actions button {
      padding: 5px 10px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }

    .btn-edit {
      background: #ffc107;
      color: #333;
    }

    .btn-delete {
      background: #dc3545;
      color: white;
    }

    .empty-state {
      text-align: center;
      padding: 40px;
      color: #666;
    }

    .overdue {
      color: #dc3545;
      font-weight: bold;
    }

    /* Edit mode */
    .task-form.editing {
      border: 2px solid #007bff;
    }

    .edit-buttons {
      display: none;
      gap: 10px;
      margin-top: 10px;
    }

    .task-form.editing .edit-buttons {
      display: flex;
    }

    .task-form.editing .add-btn {
      display: none;
    }

    /* Hide main app until connected */
    .main-app {
      display: none;
    }

    .main-app.visible {
      display: block;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>To-Do List</h1>

    <div class="connection-status loading" id="connectionStatus">
      Connecting to database...
    </div>

    <!-- Supabase Configuration Panel -->
    <div class="config-panel" id="configPanel">
      <h3>Database Configuration</h3>
      <p style="margin-bottom: 15px; color: #666; font-size: 14px;">
        Enter your Supabase project credentials. These will be saved in your browser.
      </p>
      <div class="form-group">
        <label for="supabaseUrl">Supabase URL</label>
        <input type="text" id="supabaseUrl" placeholder="https://xxxxx.supabase.co">
      </div>
      <div class="form-group">
        <label for="supabaseKey">Supabase Anon Key</label>
        <input type="text" id="supabaseKey" placeholder="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...">
      </div>
      <div class="btn-row">
        <button class="btn btn-primary" id="connectBtn">Connect</button>
        <button class="btn btn-secondary" id="clearConfigBtn">Clear Saved Config</button>
      </div>
    </div>

    <!-- Main Application -->
    <div class="main-app" id="mainApp">
      <form class="task-form" id="taskForm">
        <div class="form-row">
          <div class="form-group task-input">
            <label for="taskText">Task</label>
            <input type="text" id="taskText" required placeholder="What needs to be done?">
          </div>
          <div class="form-group">
            <label for="priority">Priority</label>
            <select id="priority">
              <option value="low">Low</option>
              <option value="medium" selected>Medium</option>
              <option value="high">High</option>
            </select>
          </div>
        </div>

        <div class="form-row">
          <div class="form-group">
            <label for="category">Category</label>
            <input type="text" id="category" list="categoryList" placeholder="Type or select">
            <datalist id="categoryList"></datalist>
          </div>
          <div class="form-group">
            <label for="dueDate">Due Date</label>
            <input type="date" id="dueDate">
          </div>
          <div class="form-group">
            <label for="reminderTime">Reminder Time</label>
            <input type="time" id="reminderTime" placeholder="HH:MM">
          </div>
        </div>

        <div class="form-row">
          <div class="form-group">
            <label for="recurringType">Recurring</label>
            <select id="recurringType">
              <option value="none">None</option>
              <option value="daily">Daily</option>
              <option value="weekly">Weekly</option>
              <option value="monthly">Monthly</option>
              <option value="custom">Custom</option>
            </select>
          </div>
        </div>

        <div class="recurring-options" id="recurringOptions">
          <label>Custom Recurrence Type:</label>
          <div class="form-row" style="margin-top: 10px;">
            <label>
              <input type="radio" name="customType" value="interval" checked> Every N days
            </label>
            <label>
              <input type="radio" name="customType" value="weekdays"> Specific weekdays
            </label>
          </div>

          <div class="interval-input visible" id="intervalInput">
            <span>Every</span>
            <input type="number" id="intervalDays" min="1" value="1">
            <span>day(s)</span>
          </div>

          <div class="weekday-selector" id="weekdaySelector">
            <button type="button" class="weekday-btn" data-day="0">Sun</button>
            <button type="button" class="weekday-btn" data-day="1">Mon</button>
            <button type="button" class="weekday-btn" data-day="2">Tue</button>
            <button type="button" class="weekday-btn" data-day="3">Wed</button>
            <button type="button" class="weekday-btn" data-day="4">Thu</button>
            <button type="button" class="weekday-btn" data-day="5">Fri</button>
            <button type="button" class="weekday-btn" data-day="6">Sat</button>
          </div>
        </div>

        <div class="form-row" style="margin-top: 15px;">
          <button type="submit" class="btn btn-primary add-btn">Add Task</button>
          <div class="edit-buttons">
            <button type="submit" class="btn btn-primary">Save Changes</button>
            <button type="button" class="btn btn-cancel" id="cancelEdit">Cancel</button>
          </div>
        </div>
      </form>

      <div class="filter-bar">
        <label class="toggle-completed">
          <input type="checkbox" id="showCompleted">
          Show completed tasks
        </label>
        <select id="categoryFilter">
          <option value="">All Categories</option>
        </select>
      </div>

      <div class="task-list" id="taskList">
        <div class="empty-state">No tasks yet. Add one above!</div>
      </div>
    </div>
  </div>

  <script>
    // Configuration
    const CONFIG_KEY = 'todoSupabaseConfig';
    const RESET_HOUR = 2; // 2am Central Time

    // State
    let supabase = null;
    let tasks = [];
    let editingTaskId = null;

    // DOM Elements
    const configPanel = document.getElementById('configPanel');
    const mainApp = document.getElementById('mainApp');
    const connectionStatus = document.getElementById('connectionStatus');
    const supabaseUrlInput = document.getElementById('supabaseUrl');
    const supabaseKeyInput = document.getElementById('supabaseKey');
    const connectBtn = document.getElementById('connectBtn');
    const clearConfigBtn = document.getElementById('clearConfigBtn');

    const taskForm = document.getElementById('taskForm');
    const taskText = document.getElementById('taskText');
    const priority = document.getElementById('priority');
    const category = document.getElementById('category');
    const dueDate = document.getElementById('dueDate');
    const reminderTime = document.getElementById('reminderTime');
    const recurringType = document.getElementById('recurringType');
    const recurringOptions = document.getElementById('recurringOptions');
    const intervalInput = document.getElementById('intervalInput');
    const intervalDays = document.getElementById('intervalDays');
    const weekdaySelector = document.getElementById('weekdaySelector');
    const weekdayBtns = document.querySelectorAll('.weekday-btn');
    const customTypeRadios = document.querySelectorAll('input[name="customType"]');
    const showCompleted = document.getElementById('showCompleted');
    const categoryFilter = document.getElementById('categoryFilter');
    const categoryList = document.getElementById('categoryList');
    const taskList = document.getElementById('taskList');
    const cancelEdit = document.getElementById('cancelEdit');

    // Initialize
    async function init() {
      setupConfigListeners();

      // Try to load saved config
      const savedConfig = localStorage.getItem(CONFIG_KEY);
      if (savedConfig) {
        const config = JSON.parse(savedConfig);
        supabaseUrlInput.value = config.url || '';
        supabaseKeyInput.value = config.key || '';

        if (config.url && config.key) {
          await connectToSupabase(config.url, config.key);
        }
      } else {
        setConnectionStatus('disconnected', 'Please configure your Supabase connection');
      }
    }

    function setupConfigListeners() {
      connectBtn.addEventListener('click', handleConnect);
      clearConfigBtn.addEventListener('click', handleClearConfig);
    }

    async function handleConnect() {
      const url = supabaseUrlInput.value.trim();
      const key = supabaseKeyInput.value.trim();

      if (!url || !key) {
        alert('Please enter both Supabase URL and Anon Key');
        return;
      }

      await connectToSupabase(url, key);
    }

    function handleClearConfig() {
      localStorage.removeItem(CONFIG_KEY);
      supabaseUrlInput.value = '';
      supabaseKeyInput.value = '';
      supabase = null;
      mainApp.classList.remove('visible');
      configPanel.style.display = 'block';
      setConnectionStatus('disconnected', 'Configuration cleared');
    }

    async function connectToSupabase(url, key) {
      setConnectionStatus('loading', 'Connecting to Supabase...');

      try {
        supabase = window.supabase.createClient(url, key);

        // Test connection by querying tasks
        const { data, error } = await supabase.from('tasks').select('id').limit(1);

        if (error) {
          throw error;
        }

        // Save config
        localStorage.setItem(CONFIG_KEY, JSON.stringify({ url, key }));

        setConnectionStatus('connected', 'Connected to Supabase');
        configPanel.style.display = 'none';
        mainApp.classList.add('visible');

        // Initialize main app
        await loadTasks();
        await processRecurringTasks();
        renderTasks();
        updateCategoryOptions();
        setupEventListeners();
        setDefaultDueDate();

      } catch (error) {
        console.error('Connection error:', error);
        setConnectionStatus('disconnected', `Connection failed: ${error.message}`);
        configPanel.style.display = 'block';
        mainApp.classList.remove('visible');
      }
    }

    function setConnectionStatus(status, message) {
      connectionStatus.className = `connection-status ${status}`;
      connectionStatus.textContent = message;
    }

    function setDefaultDueDate() {
      const today = new Date().toISOString().split('T')[0];
      dueDate.value = today;
    }

    function setupEventListeners() {
      taskForm.addEventListener('submit', handleSubmit);
      recurringType.addEventListener('change', handleRecurringChange);
      customTypeRadios.forEach(radio => {
        radio.addEventListener('change', handleCustomTypeChange);
      });
      weekdayBtns.forEach(btn => {
        btn.addEventListener('click', () => btn.classList.toggle('selected'));
      });
      showCompleted.addEventListener('change', renderTasks);
      categoryFilter.addEventListener('change', renderTasks);
      cancelEdit.addEventListener('click', resetForm);
    }

    function handleRecurringChange() {
      if (recurringType.value === 'custom') {
        recurringOptions.classList.add('visible');
      } else {
        recurringOptions.classList.remove('visible');
      }
    }

    function handleCustomTypeChange() {
      const selectedType = document.querySelector('input[name="customType"]:checked').value;
      if (selectedType === 'interval') {
        intervalInput.classList.add('visible');
        weekdaySelector.classList.remove('visible');
      } else {
        intervalInput.classList.remove('visible');
        weekdaySelector.classList.add('visible');
      }
    }

    async function loadTasks() {
      try {
        const { data, error } = await supabase
          .from('tasks')
          .select('*')
          .order('created_at', { ascending: false });

        if (error) throw error;
        tasks = data || [];
      } catch (error) {
        console.error('Error loading tasks:', error);
        tasks = [];
      }
    }

    async function saveTask(taskData) {
      try {
        const { data, error } = await supabase
          .from('tasks')
          .insert([taskData])
          .select()
          .single();

        if (error) throw error;
        return data;
      } catch (error) {
        console.error('Error saving task:', error);
        throw error;
      }
    }

    async function updateTask(id, updates) {
      try {
        const { data, error } = await supabase
          .from('tasks')
          .update(updates)
          .eq('id', id)
          .select()
          .single();

        if (error) throw error;
        return data;
      } catch (error) {
        console.error('Error updating task:', error);
        throw error;
      }
    }

    async function deleteTaskFromDb(id) {
      try {
        const { error } = await supabase
          .from('tasks')
          .delete()
          .eq('id', id);

        if (error) throw error;
      } catch (error) {
        console.error('Error deleting task:', error);
        throw error;
      }
    }

    // Get current time in Central Time
    function getCentralTime() {
      return new Date(new Date().toLocaleString('en-US', { timeZone: 'America/Chicago' }));
    }

    // Get today's reset timestamp (2am CT)
    function getTodayResetTime() {
      const ct = getCentralTime();
      const reset = new Date(ct);
      reset.setHours(RESET_HOUR, 0, 0, 0);
      return reset;
    }

    // Process recurring tasks - reset if needed
    async function processRecurringTasks() {
      const now = getCentralTime();
      const todayReset = getTodayResetTime();
      const updates = [];

      for (const task of tasks) {
        if (task.completed && task.recurring && task.recurring.type !== 'none') {
          const completedAt = new Date(task.completed_at);

          // If completed before today's 2am reset, regenerate
          if (completedAt < todayReset && now >= todayReset) {
            const newDueDate = calculateNextDueDate(task);
            updates.push({
              id: task.id,
              completed: false,
              completed_at: null,
              due_date: newDueDate,
              reminder_sent_today: false
            });
          }
        }
      }

      // Apply updates
      for (const update of updates) {
        try {
          await updateTask(update.id, {
            completed: update.completed,
            completed_at: update.completed_at,
            due_date: update.due_date,
            reminder_sent_today: update.reminder_sent_today
          });

          // Update local state
          const taskIndex = tasks.findIndex(t => t.id === update.id);
          if (taskIndex !== -1) {
            tasks[taskIndex] = { ...tasks[taskIndex], ...update };
          }
        } catch (error) {
          console.error('Error updating recurring task:', error);
        }
      }
    }

    function calculateNextDueDate(task) {
      const today = new Date();
      today.setHours(0, 0, 0, 0);

      if (!task.recurring) return formatDate(today);

      switch (task.recurring.type) {
        case 'daily':
          return formatDate(today);

        case 'weekly': {
          const next = new Date(today);
          next.setDate(next.getDate() + 7);
          return formatDate(next);
        }

        case 'monthly': {
          const next = new Date(today);
          next.setMonth(next.getMonth() + 1);
          return formatDate(next);
        }

        case 'custom': {
          if (task.recurring.interval) {
            const next = new Date(today);
            next.setDate(next.getDate() + task.recurring.interval);
            return formatDate(next);
          } else if (task.recurring.weekdays && task.recurring.weekdays.length > 0) {
            const next = new Date(today);
            next.setDate(next.getDate() + 1);
            while (!task.recurring.weekdays.includes(next.getDay())) {
              next.setDate(next.getDate() + 1);
            }
            return formatDate(next);
          }
          return formatDate(today);
        }

        default:
          return formatDate(today);
      }
    }

    function formatDate(date) {
      return date.toISOString().split('T')[0];
    }

    async function handleSubmit(e) {
      e.preventDefault();

      const taskData = {
        task: taskText.value.trim(),
        priority: priority.value,
        category: category.value.trim() || null,
        due_date: dueDate.value || null,
        reminder_time: reminderTime.value || null,
        recurring: getRecurringData()
      };

      try {
        if (editingTaskId) {
          // Update existing task
          const updated = await updateTask(editingTaskId, taskData);
          const index = tasks.findIndex(t => t.id === editingTaskId);
          if (index !== -1) {
            tasks[index] = updated;
          }
          editingTaskId = null;
          taskForm.classList.remove('editing');
        } else {
          // Create new task
          const newTask = await saveTask({
            ...taskData,
            completed: false,
            completed_at: null,
            reminder_sent_today: false
          });
          tasks.unshift(newTask);
        }

        renderTasks();
        updateCategoryOptions();
        resetForm();
      } catch (error) {
        alert('Error saving task: ' + error.message);
      }
    }

    function getRecurringData() {
      const type = recurringType.value;
      const data = { type, interval: null, weekdays: null };

      if (type === 'custom') {
        const customType = document.querySelector('input[name="customType"]:checked').value;
        if (customType === 'interval') {
          data.interval = parseInt(intervalDays.value) || 1;
        } else {
          data.weekdays = Array.from(weekdayBtns)
            .filter(btn => btn.classList.contains('selected'))
            .map(btn => parseInt(btn.dataset.day));
        }
      }

      return data;
    }

    function resetForm() {
      taskForm.reset();
      taskForm.classList.remove('editing');
      editingTaskId = null;
      recurringOptions.classList.remove('visible');
      intervalInput.classList.add('visible');
      weekdaySelector.classList.remove('visible');
      weekdayBtns.forEach(btn => btn.classList.remove('selected'));
      document.querySelector('input[name="customType"][value="interval"]').checked = true;
      setDefaultDueDate();
    }

    async function editTask(id) {
      const task = tasks.find(t => t.id === id);
      if (!task) return;

      editingTaskId = id;
      taskForm.classList.add('editing');

      taskText.value = task.task;
      priority.value = task.priority || 'medium';
      category.value = task.category || '';
      dueDate.value = task.due_date || '';
      reminderTime.value = task.reminder_time || '';
      recurringType.value = task.recurring?.type || 'none';

      if (task.recurring?.type === 'custom') {
        recurringOptions.classList.add('visible');

        if (task.recurring.interval) {
          document.querySelector('input[name="customType"][value="interval"]').checked = true;
          intervalInput.classList.add('visible');
          weekdaySelector.classList.remove('visible');
          intervalDays.value = task.recurring.interval;
        } else if (task.recurring.weekdays) {
          document.querySelector('input[name="customType"][value="weekdays"]').checked = true;
          intervalInput.classList.remove('visible');
          weekdaySelector.classList.add('visible');
          weekdayBtns.forEach(btn => {
            if (task.recurring.weekdays.includes(parseInt(btn.dataset.day))) {
              btn.classList.add('selected');
            } else {
              btn.classList.remove('selected');
            }
          });
        }
      } else {
        recurringOptions.classList.remove('visible');
      }

      taskText.focus();
    }

    async function deleteTask(id) {
      if (confirm('Are you sure you want to delete this task?')) {
        try {
          await deleteTaskFromDb(id);
          tasks = tasks.filter(t => t.id !== id);
          renderTasks();
          updateCategoryOptions();
        } catch (error) {
          alert('Error deleting task: ' + error.message);
        }
      }
    }

    async function toggleComplete(id) {
      const task = tasks.find(t => t.id === id);
      if (task) {
        const newCompleted = !task.completed;
        try {
          const updated = await updateTask(id, {
            completed: newCompleted,
            completed_at: newCompleted ? new Date().toISOString() : null,
            reminder_sent_today: newCompleted ? true : false
          });

          const index = tasks.findIndex(t => t.id === id);
          if (index !== -1) {
            tasks[index] = updated;
          }
          renderTasks();
        } catch (error) {
          alert('Error updating task: ' + error.message);
        }
      }
    }

    function renderTasks() {
      const showCompletedTasks = showCompleted.checked;
      const selectedCategory = categoryFilter.value;

      let filteredTasks = tasks.filter(task => {
        if (!showCompletedTasks && task.completed) return false;
        if (selectedCategory && task.category !== selectedCategory) return false;
        return true;
      });

      // Sort: incomplete first, then by due date, then by priority
      const priorityOrder = { high: 0, medium: 1, low: 2 };
      filteredTasks.sort((a, b) => {
        if (a.completed !== b.completed) return a.completed ? 1 : -1;
        const dateA = a.due_date || '9999-99-99';
        const dateB = b.due_date || '9999-99-99';
        if (dateA !== dateB) return dateA.localeCompare(dateB);
        return (priorityOrder[a.priority] || 1) - (priorityOrder[b.priority] || 1);
      });

      if (filteredTasks.length === 0) {
        taskList.innerHTML = '<div class="empty-state">No tasks to show.</div>';
        return;
      }

      const today = new Date().toISOString().split('T')[0];

      taskList.innerHTML = filteredTasks.map(task => {
        const isOverdue = !task.completed && task.due_date && task.due_date < today;
        const recurringLabel = getRecurringLabel(task.recurring);
        const reminderLabel = task.reminder_time ? formatTime12h(task.reminder_time) : null;

        return `
          <div class="task-item ${task.completed ? 'completed' : ''}">
            <input type="checkbox" class="task-checkbox"
              ${task.completed ? 'checked' : ''}
              onchange="toggleComplete('${task.id}')">
            <div class="task-content">
              <div class="task-text">${escapeHtml(task.task)}</div>
              <div class="task-meta">
                <span class="priority-badge priority-${task.priority || 'medium'}">${task.priority || 'medium'}</span>
                ${task.category ? `<span class="category-badge">${escapeHtml(task.category)}</span>` : ''}
                ${recurringLabel ? `<span class="recurring-badge">${recurringLabel}</span>` : ''}
                ${reminderLabel ? `<span class="reminder-badge">Remind: ${reminderLabel}</span>` : ''}
                ${task.due_date ? `<span class="${isOverdue ? 'overdue' : ''}">Due: ${formatDisplayDate(task.due_date)}</span>` : ''}
              </div>
            </div>
            <div class="task-actions">
              <button class="btn-edit" onclick="editTask('${task.id}')">Edit</button>
              <button class="btn-delete" onclick="deleteTask('${task.id}')">Delete</button>
            </div>
          </div>
        `;
      }).join('');
    }

    function getRecurringLabel(recurring) {
      if (!recurring) return '';

      switch (recurring.type) {
        case 'daily': return 'Daily';
        case 'weekly': return 'Weekly';
        case 'monthly': return 'Monthly';
        case 'custom':
          if (recurring.interval) {
            return `Every ${recurring.interval} day${recurring.interval > 1 ? 's' : ''}`;
          } else if (recurring.weekdays && recurring.weekdays.length > 0) {
            const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            return recurring.weekdays.map(d => days[d]).join(', ');
          }
          return 'Custom';
        default:
          return '';
      }
    }

    function formatTime12h(timeStr) {
      if (!timeStr) return '';
      const [hours, minutes] = timeStr.split(':');
      const h = parseInt(hours);
      const ampm = h >= 12 ? 'PM' : 'AM';
      const h12 = h % 12 || 12;
      return `${h12}:${minutes} ${ampm}`;
    }

    function formatDisplayDate(dateStr) {
      const date = new Date(dateStr + 'T00:00:00');
      return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
    }

    function escapeHtml(text) {
      if (!text) return '';
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function updateCategoryOptions() {
      const categories = [...new Set(tasks.map(t => t.category).filter(c => c))];

      categoryList.innerHTML = categories.map(c => `<option value="${escapeHtml(c)}">`).join('');

      const currentFilter = categoryFilter.value;
      categoryFilter.innerHTML = '<option value="">All Categories</option>' +
        categories.map(c => `<option value="${escapeHtml(c)}">${escapeHtml(c)}</option>`).join('');
      categoryFilter.value = currentFilter;
    }

    // Make functions available globally for onclick handlers
    window.toggleComplete = toggleComplete;
    window.editTask = editTask;
    window.deleteTask = deleteTask;

    // Initialize app
    init();
  </script>
</body>
</html>
